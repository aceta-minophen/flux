<!doctype html>
<html>
<head>
<meta charset="utf-8" />
<title>Invisible Echo Prototype â€” Seeded Maze</title>
<style>
  html,body{height:100%;margin:0;background:#0b0b0e;color:#dfe;}
  canvas{display:block;width:100%;height:100%}
  #hud{
    position:fixed; left:10px; top:10px; color:#cfe; font-family:system-ui,monospace;
    background:rgba(0,0,0,0.25); padding:8px 10px; border-radius:8px; font-size:13px;
    display:flex; gap:8px; align-items:center; z-index:5;
  }
  #seed-input{background:transparent;border:1px solid rgba(255,255,255,0.06);color:#dfe;padding:6px;border-radius:6px;width:160px}
  button{background:#0f1720;border:1px solid rgba(255,255,255,0.05);color:#dfe;padding:6px 8px;border-radius:6px;cursor:pointer}
  #saved{position:fixed; right:10px; top:10px; background:rgba(0,0,0,0.2); padding:8px;border-radius:8px; font-family:system-ui,monospace; font-size:13px; max-width:220px; max-height:60vh; overflow:auto;}
  .seed-item{padding:6px;border-radius:6px;margin-bottom:6px;background:rgba(255,255,255,0.02);cursor:pointer}
  .seed-item:hover{background:rgba(255,255,255,0.04)}
</style>
</head>
<body>
<canvas id="c"></canvas>

<div id="hud">
  <div>Seed:</div>
  <input id="seed-input" placeholder="type seed or leave blank" />
  <button id="apply">Apply</button>
  <button id="randomize">Random</button>
  <button id="copy">Copy</button>
  <button id="save">Save</button>
  <div style="opacity:0.6;margin-left:6px" id="seed-label"></div>
</div>

<div id="saved">
  <div style="font-weight:600;margin-bottom:6px">Saved Seeds</div>
  <div id="seed-list"></div>
</div>

<script>
/* ---------- Seeded RNG helpers ---------- */
/* xmur3 hash to seed a 32-bit int array from a string */
function xmur3(str){
  let h = 1779033703 ^ str.length;
  for (let i = 0; i < str.length; i++) {
    h = Math.imul(h ^ str.charCodeAt(i), 3432918353);
    h = (h << 13) | (h >>> 19);
  }
  return function() {
    h = Math.imul(h ^ (h >>> 16), 2246822507);
    h = Math.imul(h ^ (h >>> 13), 3266489909);
    return (h ^= h >>> 16) >>> 0;
  }
}
/* mulberry32 PRNG from 32-bit seed */
function mulberry32(a) {
  return function() {
    a |= 0;
    a = (a + 0x6D2B79F5) | 0;
    let t = Math.imul(a ^ (a >>> 15), 1 | a);
    t = (t + Math.imul(t ^ (t >>> 7), 61 | t)) ^ t;
    return ((t ^ (t >>> 14)) >>> 0) / 4294967296;
  }
}

/* create RNG from a textual seed (stable) */
function makeRng(seedText){
  // fallback empty seed if falsy
  const s = (seedText === undefined || seedText === null) ? '' : String(seedText);
  const h = xmur3(s)();
  return mulberry32(h);
}

/* ---------- Canvas / resize ---------- */
const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d');
function resize(){
  const dpr = Math.max(1, devicePixelRatio || 1);
  canvas.width = innerWidth * dpr;
  canvas.height = innerHeight * dpr;
  canvas.style.width = innerWidth + 'px';
  canvas.style.height = innerHeight + 'px';
  ctx.setTransform(dpr,0,0,dpr,0,0);
}
addEventListener('resize', resize);
resize();

/* ---------- Config (same as before) ---------- */
let cellSize = 48;
let cols = Math.max(9, Math.floor(innerWidth / cellSize));
let rows = Math.max(9, Math.floor(innerHeight / cellSize));
const roomAttempts = 100;
const minRoomSize = 2;
const maxRoomSize = 5;
const doorThickness = 8;
const echoFadeSpeed = 0.6;

/* ---------- Level data ---------- */
let grid = [];
let doors = [];
let savedSeedsKey = 'invisible-echo-saved-seeds-v1';

/* ---------- RNG: will be replaced with seeded RNG on generate ---------- */
let rng = Math.random;

/* helper random functions using rng */
function rand(){ return rng(); }
function randInt(a,b){ return Math.floor(rand()*(b-a+1)) + a; }

/* ---------- grid and geometry helpers ---------- */
function makeGrid(c,r){
  const g = [];
  for(let y=0;y<r;y++){
    const row=[];
    for(let x=0;x<c;x++){
      row.push({x,y, walls:{n:true,e:true,s:true,w:true}, inMaze:false, isRoom:false});
    }
    g.push(row);
  }
  return g;
}
function inBounds(x,y){ return x>=0 && x<cols && y>=0 && y<rows; }
function neigh(x,y){
  return [
    {dx:0,dy:-1,dir:'n',opp:'s'},
    {dx:1,dy:0,dir:'e',opp:'w'},
    {dx:0,dy:1,dir:'s',opp:'n'},
    {dx:-1,dy:0,dir:'w',opp:'e'},
  ];
}

/* ---------- generation (all uses rand()/randInt) ---------- */
function carveMaze(){
  for(let y=0;y<rows;y++) for(let x=0;x<cols;x++){ grid[y][x].inMaze=false; grid[y][x].walls={n:true,e:true,s:true,w:true}; }
  const stack = [];
  const sx=0, sy=0;
  grid[sy][sx].inMaze=true;
  stack.push(grid[sy][sx]);
  while(stack.length){
    const cell = stack[stack.length-1];
    const x = cell.x, y = cell.y;
    const candidates = [];
    for(const n of neigh(x,y)){
      const nx = x + n.dx, ny = y + n.dy;
      if(inBounds(nx,ny) && !grid[ny][nx].inMaze) candidates.push({nx,ny,dir:n.dir,opp:n.opp});
    }
    if(candidates.length === 0){ stack.pop(); continue; }
    const pick = candidates[Math.floor(rand()*candidates.length)];
    const ncell = grid[pick.ny][pick.nx];
    cell.walls[pick.dir] = false;
    ncell.walls[pick.opp] = false;
    ncell.inMaze = true;
    stack.push(ncell);
  }

  // add a handful of extra connections to create loops (deterministic from RNG)
  const loops = Math.floor((cols*rows)/12);
  for(let i=0;i<loops;i++){
    const rx = randInt(0, cols-1);
    const ry = randInt(0, rows-1);
    const dlist = neigh(rx,ry).filter(n => inBounds(rx+n.dx, ry+n.dy));
    if(dlist.length===0) continue;
    const d = dlist[randInt(0, dlist.length-1)];
    grid[ry][rx].walls[d.dir] = false;
    grid[ry+d.dy][rx+d.dx].walls[d.opp] = false;
  }
}

function placeRooms(){
  const placed=[];
  for(let attempt=0; attempt<roomAttempts; attempt++){
    const rw = randInt(minRoomSize, maxRoomSize);
    const rh = randInt(minRoomSize, maxRoomSize);
    const rx = randInt(0, Math.max(0, cols - rw));
    const ry = randInt(0, Math.max(0, rows - rh));
    // avoid overlap with 1-cell padding
    let ok=true;
    for(const p of placed){
      if(rx < p.x + p.w + 1 && rx + rw + 1 > p.x && ry < p.y + p.h + 1 && ry + rh + 1 > p.y){ ok=false; break; }
    }
    if(!ok) continue;
    for(let yy=ry; yy<ry+rh; yy++){
      for(let xx=rx; xx<rx+rw; xx++){
        const c = grid[yy][xx];
        c.isRoom = true;
        if(xx < rx + rw - 1){ c.walls.e = false; grid[yy][xx+1].walls.w = false; }
        if(yy < ry + rh - 1){ c.walls.s = false; grid[yy+1][xx].walls.n = false; }
      }
    }
    placed.push({x:rx,y:ry,w:rw,h:rh});
  }
  return placed;
}

function createDoors(rooms){
  doors = [];
  for(const r of rooms){
    for(let yy=r.y; yy<r.y+r.h; yy++){
      for(let xx=r.x; xx<r.x+r.w; xx++){
        for(const n of neigh(xx,yy)){
          const nx=xx+n.dx, ny=yy+n.dy;
          if(!inBounds(nx,ny)) continue;
          if(nx >= r.x && nx < r.x + r.w && ny >= r.y && ny < r.y + r.h) continue;
          if(grid[yy][xx].walls[n.dir]){
            if(rand() < 0.45){ // door chance from RNG
              grid[yy][xx].walls[n.dir] = false;
              grid[ny][nx].walls[n.opp] = false;
              doors.push({x:xx,y:yy, dir:n.dir});
            }
          }
        }
      }
    }
  }
}

/* ---------- generate level using a provided seed string ---------- */
function generateLevel(seedText){
  // set RNG based on seed
  rng = makeRng(seedText);
  // recompute grid size in case of resize/viewport changes
  cols = Math.max(9, Math.floor(innerWidth / cellSize));
  rows = Math.max(9, Math.floor(innerHeight / cellSize));
  grid = makeGrid(cols, rows);
  carveMaze();
  const rooms = placeRooms();
  // more small random openups
  const extras = Math.floor((cols*rows)/14);
  for(let i=0;i<extras;i++){
    const rx = randInt(0, cols-1);
    const ry = randInt(0, rows-1);
    const dlist = neigh(rx,ry).filter(n => inBounds(rx+n.dx, ry+n.dy));
    if(dlist.length===0) continue;
    const d = dlist[randInt(0, dlist.length-1)];
    grid[ry][rx].walls[d.dir] = false;
    grid[ry+d.dy][rx+d.dx].walls[d.opp] = false;
  }
  createDoors(rooms);

  // ensure start open
  grid[0][0].isRoom = grid[0][0].inMaze = true;
  // update HUD label
  document.getElementById('seed-label').textContent = seedText ? seedText : '(empty seed)';
  // set global activeSeed var
  activeSeed = seedText;
}

/* ---------- Player + movement + drawing (same ideas as before) ---------- */
let px = cellSize*0.5, py = cellSize*0.5, speed = 160;
let echoes = [];
const keys = {};
addEventListener('keydown', e=>keys[e.key]=true);
addEventListener('keyup', e=>keys[e.key]=false);

function cellAt(px,py){
  return {cx: Math.floor(px / cellSize), cy: Math.floor(py / cellSize)};
}
function wallBetween(cx,cy,dir){
  if(!inBounds(cx,cy)) return true;
  return grid[cy][cx].walls[dir];
}
function tryMove(dx,dy,dt){
  const nx = px + dx*speed*dt;
  const ny = py + dy*speed*dt;
  let allowX=true, allowY=true;
  if(dx !== 0){
    const probeX = nx, probeY = py;
    const c = cellAt(probeX, probeY);
    const cx=c.cx, cy=c.cy;
    if(dx > 0){
      const crossingX = probeX >= (cx+1)*cellSize - 0.5;
      if(crossingX && wallBetween(cx,cy,'e')) allowX=false;
    } else {
      const crossingX = probeX <= cx*cellSize + 0.5;
      if(crossingX && wallBetween(cx,cy,'w')) allowX=false;
    }
  }
  if(dy !== 0){
    const probeX = px, probeY = ny;
    const c = cellAt(probeX, probeY);
    const cx=c.cx, cy=c.cy;
    if(dy > 0){
      const crossingY = probeY >= (cy+1)*cellSize - 0.5;
      if(crossingY && wallBetween(cx,cy,'s')) allowY=false;
    } else {
      const crossingY = probeY <= cy*cellSize + 0.5;
      if(crossingY && wallBetween(cx,cy,'n')) allowY=false;
    }
  }
  if(allowX) px = nx;
  if(allowY) py = ny;
}

/* ---------- drawing ---------- */
function drawGrid(){
  ctx.fillStyle = 'rgba(11,11,14,1)';
  ctx.fillRect(0,0,canvas.width,canvas.height);
  // floors
  for(let y=0;y<rows;y++){
    for(let x=0;x<cols;x++){
      const c = grid[y][x];
      if(c.isRoom) ctx.fillStyle = 'rgba(22,25,30,1)';
      else ctx.fillStyle = 'rgba(8,9,11,1)';
      ctx.fillRect(x*cellSize+1, y*cellSize+1, cellSize-2, cellSize-2);
    }
  }
  // thin walls
  ctx.lineWidth = 2;
  ctx.strokeStyle = 'rgba(180,180,200,0.18)';
  ctx.beginPath();
  for(let y=0;y<rows;y++){
    for(let x=0;x<cols;x++){
      const c = grid[y][x];
      const sx = x*cellSize, sy = y*cellSize;
      if(c.walls.n){ ctx.moveTo(sx, sy); ctx.lineTo(sx+cellSize, sy); }
      if(c.walls.e){ ctx.moveTo(sx+cellSize, sy); ctx.lineTo(sx+cellSize, sy+cellSize); }
      if(c.walls.s){ ctx.moveTo(sx+cellSize, sy+cellSize); ctx.lineTo(sx, sy+cellSize); }
      if(c.walls.w){ ctx.moveTo(sx, sy+cellSize); ctx.lineTo(sx, sy); }
    }
  }
  ctx.stroke();

  // doors: thick bright lines
  for(const d of doors){
    const x=d.x, y=d.y;
    const sx = x*cellSize, sy = y*cellSize;
    ctx.save();
    ctx.lineCap = 'butt';
    ctx.lineWidth = doorThickness;
    ctx.strokeStyle = 'rgba(140,220,255,0.95)';
    ctx.beginPath();
    if(d.dir === 'n'){ ctx.moveTo(sx + cellSize*0.2, sy); ctx.lineTo(sx + cellSize*0.8, sy); }
    if(d.dir === 's'){ ctx.moveTo(sx + cellSize*0.2, sy+cellSize); ctx.lineTo(sx + cellSize*0.8, sy+cellSize); }
    if(d.dir === 'w'){ ctx.moveTo(sx, sy + cellSize*0.2); ctx.lineTo(sx, sy + cellSize*0.8); }
    if(d.dir === 'e'){ ctx.moveTo(sx+cellSize, sy + cellSize*0.2); ctx.lineTo(sx+cellSize, sy + cellSize*0.8); }
    ctx.stroke();
    ctx.restore();
  }
}

function drawEchoes(dt){
  for(let i=echoes.length-1;i>=0;i--){
    const e = echoes[i];
    e.alpha -= dt * echoFadeSpeed;
    if(e.alpha <= 0) echoes.splice(i,1);
    else {
      ctx.beginPath();
      ctx.fillStyle = `rgba(150,200,255,${e.alpha*0.12})`;
      ctx.arc(e.x,e.y,40,0,Math.PI*2);
      ctx.fill();
    }
  }
}

/* ---------- main loop ---------- */
let last = performance.now();
function loop(now){
  const dt = (now-last)/1000; last = now;
  let dx=0, dy=0;
  if(keys['ArrowLeft']||keys['a']) dx=-1;
  if(keys['ArrowRight']||keys['d']) dx=1;
  if(keys['ArrowUp']||keys['w']) dy=-1;
  if(keys['ArrowDown']||keys['s']) dy=1;
  const len = Math.hypot(dx,dy) || 1;
  dx /= len; dy /= len;
  if(Math.abs(dx) > 0 || Math.abs(dy) > 0) echoes.push({x:px,y:py,alpha:1});
  tryMove(dx,dy,dt);
  drawGrid();
  drawEchoes(dt);
  ctx.beginPath();
  ctx.fillStyle='rgba(255,255,255,0.95)';
  ctx.arc(px,py,4,0,Math.PI*2);
  ctx.fill();
  requestAnimationFrame(loop);
}
requestAnimationFrame(loop);

/* ---------- player start ---------- */
function resetPlayerToTopLeft(){ px = cellSize*0.5; py = cellSize*0.5; }
resetPlayerToTopLeft();

/* ---------- seed UI + persistence ---------- */
const seedInput = document.getElementById('seed-input');
const applyBtn = document.getElementById('apply');
const randomBtn = document.getElementById('randomize');
const copyBtn = document.getElementById('copy');
const saveBtn = document.getElementById('save');
const seedList = document.getElementById('seed-list');

let activeSeed = '';

// helpers localStorage
function loadSavedSeeds(){ try{ return JSON.parse(localStorage.getItem(savedSeedsKey) || '[]'); }catch(e){ return []; } }
function saveSavedSeeds(arr){ localStorage.setItem(savedSeedsKey, JSON.stringify(arr.slice(0,50))); } // cap 50

function renderSavedSeeds(){
  const arr = loadSavedSeeds();
  seedList.innerHTML = '';
  for(const s of arr){
    const div = document.createElement('div');
    div.className = 'seed-item';
    div.textContent = s;
    div.title = 'Click to load this seed';
    div.addEventListener('click', ()=>{ seedInput.value = s; applySeed(s); });
    seedList.appendChild(div);
  }
}

function applySeed(seedText){
  generateLevel(seedText);
  resetPlayerToTopLeft();
  // update URL (without reload)
  const url = new URL(location);
  if(seedText) url.searchParams.set('seed', seedText);
  else url.searchParams.delete('seed');
  history.replaceState({}, '', url);
}

/* UI button actions */
applyBtn.addEventListener('click', ()=>{ applySeed(seedInput.value.trim()); });
randomBtn.addEventListener('click', ()=>{
  // create a human-friendly random seed using timestamp + random chars (but still deterministic when used)
  const s = 'seed-' + Date.now().toString(36) + '-' + Math.floor(Math.random()*1e6).toString(36);
  seedInput.value = s;
  applySeed(s);
});
copyBtn.addEventListener('click', async ()=>{
  try{
    await navigator.clipboard.writeText(activeSeed || seedInput.value || '');
    copyBtn.textContent = 'Copied';
    setTimeout(()=>copyBtn.textContent = 'Copy', 900);
  } catch(e){ copyBtn.textContent = 'Fail'; setTimeout(()=>copyBtn.textContent='Copy',900); }
});
saveBtn.addEventListener('click', ()=>{
  const s = seedInput.value.trim() || activeSeed || '';
  if(!s) return;
  const arr = loadSavedSeeds();
  // move to front
  const filtered = arr.filter(a=>a!==s);
  filtered.unshift(s);
  saveSavedSeeds(filtered);
  renderSavedSeeds();
});

/* handle URL seed on load */
function getSeedFromURL(){
  try{
    const params = new URLSearchParams(location.search);
    return params.get('seed');
  } catch(e){ return null; }
}

/* initialize */
function init(){
  renderSavedSeeds();
  const urlSeed = getSeedFromURL();
  const initial = urlSeed !== null ? urlSeed : '';
  seedInput.value = initial;
  applySeed(initial);
}
init();

/* save seed shown in HUD for copying */
const seedLabel = document.getElementById('seed-label');
const seedObserver = new MutationObserver(()=>{ activeSeed = seedLabel.textContent; });
seedObserver.observe(seedLabel, {childList:true, subtree:true});

/* keyboard regenerate */
addEventListener('keypress', (e)=>{ if(e.key === 'r'){ applySeed(seedInput.value.trim()); } });

/* on resize regenerate (debounced) */
let resizeTimeout;
addEventListener('resize', ()=>{
  clearTimeout(resizeTimeout);
  resizeTimeout = setTimeout(()=>{
    resize();
    // keep current seed
    applySeed(seedInput.value.trim());
    resetPlayerToTopLeft();
  }, 180);
});

</script>
</body>
</html>
